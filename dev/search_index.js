var documenterSearchIndex = {"docs":
[{"location":"iterators/#Iterators-documentation","page":"Iterators","title":"Iterators documentation","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"An important goal of this package is to provide several iterators useful during local search.","category":"page"},{"location":"iterators/#OrderedProductIterator","page":"Iterators","title":"OrderedProductIterator","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"Given sets AB, the Cartesian product A times B is defined as:","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"    A times B = (ab)  a in A text and  b in B ","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"For example, if:","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"beginalign*\n             A = 123  \n             B = 1 2 \n    A times B = (11)(12)(21)(22)(31)(32)\nendalign*","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"An iterator for the Cartesian product of sets (or AbstractArrays) is available in julia through the struct Iterators.ProductIterator. The OrderedProductIterator is similar to Iterators.ProductIterator, but allows the user to pass an order along with the sets. ","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"using PolyaDataStructures\nA = [1,2,3]\nB = [1,2]\nI = orderedproduct((2,1), A, B)\ncollect(I)","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"The orderedproduct can be used to generate various parameter space enumeration schemes for local search operations by relying on the indexset of a datastructure. These can compose into neighborhood enumerations which can be used during optimization.","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"using PolyaDataStructures, Plots\ns = Tour([i for i in 1:3])\nJ = indexset(s)\nI1 = orderedproduct((1,2), J, J)\nI2 = orderedproduct((2,1), J, J)\nprintln(collect(I1))\nprintln(collect(I2))","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"Based on the default definition of the index set of a struct and its reverse, following orders can be defined:","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"using PolyaDataStructures, Plots\nn = 5 \ns = Tour([i for i in 1:n])\nJ = indexset(s)\nJr = Iterators.reverse(J)\nð’¥ = (J, Jr)         # set options\nð’¯ = ((1,2),(2,1))   # Different orders\n\nconfigs = Iterators.product(ð’¯,ð’¥,ð’¥)\nIset = map(c -> orderedproduct(c[1], c[2:end]...), configs)\nP = enumerationplot.(Iset, size.(Iset))\nplot(P..., layout=(2,4), size = (800, 400))","category":"page"},{"location":"iterators/#OffsetOrderIterator","page":"Iterators","title":"OffsetOrderIterator","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"The offset iterator takes a quadratic iterator I as input and uses it to construct a new iterator J with as elements the transformation of the elements t in I in the original iterator according to t -> (t[1], (t[1] + t[2] - 1) % iter.n + 1).","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"using PolyaDataStructures\nA = [1,2,3]\nB = [1,2,3]\nI = orderedproduct((2,1), A, B)\nJ = OffsetOrderIterator(I, 3)","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"We can reuse the OrderedProductIterators we defined earlier as a basis to create a new set of iterators. ","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"using PolyaDataStructures, Plots\nn = 5\nJ = 1:n\nJr = Iterators.reverse(J)\nð’¥ = (J, Jr)\nð’¯ = ((1,2),(2,1))\nconfigs = Iterators.product(ð’¯,ð’¥,ð’¥)\nIset = map(c -> orderedproduct(c[1], c[2:end]...), configs)\nIoffset = map(I -> OffsetOrderIterator(I, n), Iset)\nP = enumerationplot.(Ioffset, Ref((n,n)))\nplot(P..., layout=(2,4), size = (800, 400))","category":"page"},{"location":"iterators/#Predefined-quadratic-operators","page":"Iterators","title":"Predefined quadratic operators","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"Two predefined quadratic operators are available, which can be configured in various ways, resulting in 12 different iteration schemes.","category":"page"},{"location":"iterators/#NoDiagMatrixIterator","page":"Iterators","title":"NoDiagMatrixIterator","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"Given I = 123dotsn, iterates over I times I while skipping the elements on the diagonal (that is, the pairs (ij) i = j). Is defined in terms of n and takes a trait indicating the main iteration direction.","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"using PolyaDataStructures\nn = 3\ncollect(NDMI(ColMajor, n))","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"This gives rise to a total of six iterators.","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"using PolyaDataStructures, Plots\nn = 5\norders = [ColMajor, RowMajor, DiagMajor]\nIset = [NDMI(order,n) for order in orders] \nIset = vcat(Iset, Iterators.reverse.(Iset))\nP = enumerationplot.(Iset, Ref((n,n)))\nplot(P..., layout=(2,3), size = (600, 400))","category":"page"},{"location":"iterators/#LowerTriMatrixIterator","page":"Iterators","title":"LowerTriMatrixIterator","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"Given I = 123dotsn, iterates over I times I while skipping the elements on or above the diagonal (that is, the pairs (ij) i  j). Is defined in terms of n and takes a trait indicating the main iteration direction.","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"using PolyaDataStructures\nn = 3\ncollect(LTMI(ColMajor, n))","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"This gives rise to a total of six iterators.","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"using PolyaDataStructures, Plots\nn = 5\norders = [ColMajor, RowMajor, DiagMajor]\nIset = [LTMI(order,n) for order in orders] \nIset = vcat(Iset, Iterators.reverse.(Iset))\nP = enumerationplot.(Iset, Ref((n,n)))\nplot(P..., layout=(2,3), size = (600, 400))","category":"page"},{"location":"iterators/#Runtime-comparison-with-definition-based-on-orderedproduct","page":"Iterators","title":"Runtime comparison with definition based on orderedproduct","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"Some of the iterators LTMI and NDMI can also be constructed by applying filters to orderedproduct. However, typically, the NDMI/LTMIimplementation outperforms the more generic implementation using orderedproduct.","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"using PolyaDataStructures, BenchmarkTools\nn = 500;\nI = NDMI(ColMajor, n);\n@benchmark collect($I)\nI = Iterators.filter(Ï• -> Ï•[1] != Ï•[2], Iterators.product(1:n, 1:n));\n@benchmark collect($I)\nI = NDMI(RowMajor, n);\n@benchmark collect($I)\nI = Iterators.filter(Ï• -> Ï•[1] != Ï•[2], orderedproduct((2,1), 1:n, 1:n));\n@benchmark collect($I)\n","category":"page"},{"location":"iterators/#DisjointUnionIterator","page":"Iterators","title":"DisjointUnionIterator","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"The disjoint union of a family of sets consists of a new set, of which the members are the members of the old sets, each labeled with the index of the original set they belonged to.","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"sqcup_i in I A_i = cup_i in I (ix) x in A_i ","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"The DisjointUnionIterator is an iterator over the disjoint union of sets. ","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"using PolyaDataStructures\ns1 = [:a,:b,:c]\ns2 = [:d,:e,:f]\n\nI = DisjointUnionIterator(s1, s2)\ncollect(I)","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"It can be used to construct an index set over nested indexed structs. Furthermore, the nesting can be set at various nesting levels.","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"using PolyaDataStructures\nv = [[[1,32],[2,7,5]],[[4],[12,3]],[[8,9],[10,12]]]\nI = indexset(v, 3)\nmap(i -> i => v[i], I)","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"This enables us to define various operations on v based on the index structure.","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"using PolyaDataStructures\nv = [[[1,32],[2,7,5]],[[4],[12,3]],[[8,9],[10,12]]]\nI1 = indexset(v,1)\nI2 = indexset(v,2)\nI3 = indexset(v,3)\n# Three examples\nprintln(\"Original structure:\") \nprintln(v) \nprintln(\"First and last element of top level are swapped (swap two vectors of vectors):\") \nswap!(v, first(I1), last(I1))\nprintln(v)\nprintln(\"First and last element of second level are swapped (swap two vectors):\") \nswap!(v, first(I2), last(I2))\nprintln(v) \nprintln(\"First and last element of lowest level are swapped (swap two integers):\")\nswap!(v, first(I3), last(I3))\nprintln(v)","category":"page"},{"location":"datastructures/#Datastructures","page":"Datastructures","title":"Datastructures","text":"","category":"section"},{"location":"datastructures/#Tour","page":"Datastructures","title":"Tour","text":"","category":"section"},{"location":"datastructures/","page":"Datastructures","title":"Datastructures","text":"Representation for a tour. Essentially boils down to a wrapper-type for AbstractArrays. The wrapper provides function `eachedge(t)', which returns pairs of successive elements in the tour (in other words, the sequence of edges which define the tour). ","category":"page"},{"location":"datastructures/","page":"Datastructures","title":"Datastructures","text":"using PolyaDataStructures\nv = [1,2,3]\nt = Tour(v)\nprintln(t)\nprintln(\"Index set: \", indexset(t))\ncollect(eachedge(t))","category":"page"},{"location":"datastructures/#TourWithOrigin","page":"Datastructures","title":"TourWithOrigin","text":"","category":"section"},{"location":"datastructures/","page":"Datastructures","title":"Datastructures","text":"Almost identical to Tour but wit a fixed origin. As such, indexset(t::TourWithOrigin) = 2:length(t)","category":"page"},{"location":"datastructures/","page":"Datastructures","title":"Datastructures","text":"using PolyaDataStructures\nv = [1,2,3]\nt = TourWithOrigin(v)\nprintln(t)\nprintln(\"Index set: \", indexset(t))\ncollect(eachedge(t))","category":"page"},{"location":"#PolyaDataStructures","page":"Home","title":"PolyaDataStructures","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"This package provides several datastructures, functions and iterators which may be useful during the design of heuristic solution methods for combinatorial optimization problems.","category":"page"},{"location":"","page":"Home","title":"Home","text":"custom indexing of a struct through its indexset, which enables multilevel indexing\ndefinition of various standard combinatorial operations\nvarious structures representing reducing operations, enriched with modifications to speed up their computation when applied to certain combinatorial objects.","category":"page"}]
}
