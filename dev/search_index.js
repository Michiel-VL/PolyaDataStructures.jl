var documenterSearchIndex = {"docs":
[{"location":"iterators/#Iterators-documentation","page":"Iterators","title":"Iterators documentation","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"A substantial part of the ","category":"page"},{"location":"iterators/#OrderedProductIterator","page":"Iterators","title":"OrderedProductIterator","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"using PolyaDataStructures, Plots\nn = 10\nJ = 1:n\nJr = Iterators.reverse(J)\n𝒥 = (J, Jr)\n𝒯 = ((1,2),(2,1))\nconfigs = Iterators.product(𝒯,𝒥,𝒥)\nIset = map(c -> orderedproduct(c[1], c[2:end]...), configs)\nP = enumerationplot.(Iset, Ref((n,n)), markersize=5, size=(800,800))\nplot(P..., layout=(4,2), size = (1000, 2000))","category":"page"},{"location":"iterators/#OffsetOrderIterator","page":"Iterators","title":"OffsetOrderIterator","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"using PolyaDataStructures, Plots\nn = 5\nJ = 1:n\nJr = Iterators.reverse(J)\n𝒥 = (J, Jr)\n𝒯 = ((1,2),(2,1))\nconfigs = Iterators.product(𝒯,𝒥,𝒥)\nIset = map(c -> orderedproduct(c[1], c[2:end]...), configs)\nIoffset = map(I -> OffsetOrderIterator(I, n), Iset)\nP = enumerationplot.(Ioffset, Ref((n,n)))\nplot(P..., layout=(4,2), size = (1000, 2000))","category":"page"},{"location":"iterators/#DisjointUnionIterator","page":"Iterators","title":"DisjointUnionIterator","text":"","category":"section"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"The disjoint union of a family of sets consists of a new set, of which the members are the members of the old sets, each labeled with the index of the original set they belonged to.","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"sqcup_i in I A_i = Union_i in I (xi) x in A_i ","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"The DisjointUnionIterator provided gives an iterator whic","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"using PolyaDataStructures\ns1 = [:a,:b,:c]\ns2 = [:d,:e,:f]\n\nI = DisjointUnionIterator(s1, s2)\ncollect(I)","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"The disjoint union iterator can be used to construct an index set over nested indexed structs. The index set can be defined at a certain depth of the nesting.","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"using PolyaDataStructures\nv = [[[1,32],[2,7,5]],[[4],[12,3]],[[8,9],[10,12]]]\nI = indexset(v, 3)\nmap(i -> i => v[i], I)","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"This enables us to define various operations on v based on the index structure.","category":"page"},{"location":"iterators/","page":"Iterators","title":"Iterators","text":"using PolyaDataStructures\nv = [[[1,32],[2,7,5]],[[4],[12,3]],[[8,9],[10,12]]]\nI1 = indexset(v,1)\nI2 = indexset(v,2)\nI3 = indexset(v,3)\n# Three examples\nprintln(v)\nswap!(v, first(I1), last(I1))\nprintln(v)\nswap!(v, first(I2), last(I2))\nprintln(v)\nswap!(v, first(I3), last(I3))\nprintln(v)","category":"page"},{"location":"datastructures/#DataStructures","page":"Datastructures","title":"DataStructures","text":"","category":"section"},{"location":"datastructures/#Tour","page":"Datastructures","title":"Tour","text":"","category":"section"},{"location":"datastructures/","page":"Datastructures","title":"Datastructures","text":"Representation for a tour. Essentially boils down to a wrapper-type for AbstractArrays. The wrapper provides function `eachedge(t)', which returns pairs of successive elements in the tour (in other words, the sequence of edges which define the tour). ","category":"page"},{"location":"datastructures/","page":"Datastructures","title":"Datastructures","text":"using PolyaDataStructures\nv = [1,2,3]\nt = Tour(v)\nprintln(t)\nprintln(\"Index set: \", indexset(t))\ncollect(eachedge(t))","category":"page"},{"location":"datastructures/#TourWithOrigin","page":"Datastructures","title":"TourWithOrigin","text":"","category":"section"},{"location":"datastructures/","page":"Datastructures","title":"Datastructures","text":"Almost identical to Tour but wit a fixed origin. As such, indexset(t::TourWithOrigin) = 2:length(t)","category":"page"},{"location":"datastructures/","page":"Datastructures","title":"Datastructures","text":"using PolyaDataStructures\nv = [1,2,3]\nt = TourWithOrigin(v)\nprintln(t)\nprintln(\"Index set: \", indexset(t))\ncollect(eachedge(t))","category":"page"},{"location":"#PolyaDataStructures","page":"Home","title":"PolyaDataStructures","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"A number of datastructures which can be used for combinatorial optimization.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Following functionality is provided.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Solution Representations\nObjective Function Representations\nIterators","category":"page"}]
}
